/** ****************************************************************************
  I2CX  Reference Driver File

  @Company
	Microchip Technology Inc.

  @File Name
	I2C_Master_MX1.c

  @Summary
	This is reference driver file for the I2C1 peripheral.

  @Description
	This file provide interrupt driver for I2C1.
	Generation Information :
		Product Revision  :  MPLABï¿½ Code Configurator - v2.25.2
		Device            :  PIC24FJ256GB110
		Device            :  PIC24FJ64GB002
		Driver Version    :  2.1 Mysil
	The drivers are tested against the following:
		Compiler          :  XC32 v1.43
		MPLAB 	          :  MPLAB X v3.55
		Reference driver file modified by Mysil

	Remarks:
		When only one instance of I2C Master is in use, I2C file and function names without any index may be used.
		When multiple instances is wanted, filename and external functions will need different global names.
 *		Enumeration types and State constant  should Not need changes for instances.
 *		SFR Register and Field macros, are internal within each instance of the driver code,
 *		and do only need to be changed in macro definitions: #define ... lines.
 *
 *		To use this driver with Microchip Code Configurator projects, 
 *		use MCC with a new or existing MPLAB project to configure pins and drivers, 
 *		including I2C devices, and Generate MCC code the ordinary way.
 *		Configure Interrupts and interrupt priorities in MCC. 
 *		Copy this driver files into the project directory, and introduce in MPLAB project.
 *		Then Edit the file: /mcc_generated_files/mcc.h like this:
 *		<code>
 *			//#include "i2c1.h"					// Remove the include of MCC generated header file
 *			// Define _XTAL_FREQ before including I2C_Master.h 
 *			#define _XTAL_FREQ  32000000UL		// Keep _XTAL_FREQ generated by MCC
 *			#include "I2C_Master.h"				// include I2C_Master.h header file.
 *		<code>
 *		Review and adjust Configuration Definitions section in this file: I2C_Master_FJ.c
 *		to correspond with selections done in MCC.
 *
 *		In MPLAB X, mark the driver files generated by MCC:
 *		    i2cx.h and i2cx.c as 'Excluded from Configuration'.
 *
 *		Driver files may be located in any directory within the project,
 *		if header file I2C_Master.h is located in /mcc_generated_files/I2C_Master.h 
 *		the same relative paths may be used as for other mcc header files. 
 *		With any other location of header files, a include directory search list in MPLAB may be needed.
 *		E.g.: ".;mcc_generated_files;..\Source" 
 *		the directory search list is edited in MPLAB 'Project Properties'
 *		 'xc32_gcc' 'Preprocessing and Messages' 'Extra include directories:'
 *
 * Revision:
 *	Rewrite with changed Task queue structure definitions.
 *	Mysil		2016.05.31	10-bit I2C addresses for Master and Slave.
 *	Mysil		2017.04.25	PIC24FJ64GB002
 *
 *	This is a configured version of the driver for PIC24FJ devices 
 *	without Slave functions.
 */

/*
Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.

Microchip licenses to you the right to use, modify, copy and distribute
Software only when embedded on a Microchip microcontroller or digital signal
controller that is integrated into your product or third party product
(pursuant to the sublicense terms in the accompanying license agreement).

You should refer to the license agreement accompanying this Software for
additional information regarding your rights and obligations.

SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
 */

#undef  __PIC32_PIN_SET__				/* Must be here to avoid a snag in macros defined by compiler. */
#include "xc.h"
//#include "mcc.h"
#include "mcc_generated_files/mcc.h"
#include "I2C_Master.h"
//#include "I2C_Slave.h"

//#include "pin_manager.h"
#include "mcc_generated_files/pin_manager.h"
#include "main.h"						/* Diagnostic and time measurement. */

/*******************************************************************************
 *  Configuration Definitions
 *	defined for I2C1
 */
#define  I2C_INSTANCE	2	/* This is Instance number used in API functions */
#define	 I2C_CHANNEL	1	/* This is Hardware peripheral module number. */
							/* Channel macro must be defined before including I2C_Pins.i */
#ifndef   __PIC24_PIN_SET__
  #if defined __PIC24FJ64GB002__
	#define __PIC24_PIN_SET__	'B'
  #elif defined __PIC24FJ256GB110__
	#define __PIC24_PIN_SET__ 'L'
  #else
	#define __PIC24_PIN_SET__	'B'
  #endif
#endif
#include "I2C_Pins_FJ.h"		/* For devices without support from Pin manager, define I2C pins. */

#define		I2C_FREQ		100000		/* I2C Bitrate. */
										/* MCC Interrupt manager initialize may override this */
#ifndef		I2C_PRIORITY				/* Interrupt priority 3 if not othervise defined */
  #define	I2C_PRIORITY			3
  #define	I2C_IPL			IPL3SOFT	/* Note! Attribute argument in Interrupt handler: IPL3SOFT */
#endif

#ifndef		I2C_TASK_QUEUE_LENGTH
  #ifdef							I2C1_CONFIG_TASK_QUEUE_LENGTH
	#define	I2C_TASK_QUEUE_LENGTH	I2C1_CONFIG_TASK_QUEUE_LENGTH
  #elif defined						I2C_CONFIG_TASK_QUEUE_LENGTH
	#define	I2C_TASK_QUEUE_LENGTH	I2C_CONFIG_TASK_QUEUE_LENGTH
  #else
	#define	I2C_TASK_QUEUE_LENGTH	4
  #endif
#endif
#define		I2C_SLAVE_ENABLE		0	/* I2C Slave functions not to be used. */
#define		I2C_SLAVE_A10_Enable	1

#ifndef		DIAG_INT_H					/* Test if diagnostic timing is defined. */
										/* Define as empty when not needed. */
	#define DIAG_INT_H					// LATBSET = _LATB_LATB11_MASK;
	#define	DIAG_INT_L					// LATBCLR = _LATB_LATB11_MASK;
#endif
										/* For Compatibility with application code
										 * using old Message status values,
										 * use Pending for all active status alternatives. */
#define I2C_MESSAGE_ACTIVE	I2C_MESSAGE_PENDING
#define I2C_MESSAGE_RETRY	I2C_MESSAGE_PENDING

#if defined __XC8__  || defined __XC16__
  #define	MS_TICK		1
#elif defined __XC32__
  #define	MS_TICK		_XTAL_FREQ/2000
#endif
/** ****************************************************************************
 *	Section: Data Types
 */
/** ****************************************************************************
  I2C Driver Queue Entry Type

  @Summary
    Defines the object used for an entry in the i2c queue.

  @Description
    This type defines the object in the i2c queue.
   Each entry is a self-contained transaction,
   with possibility to link tasks together to be performed without releasing the bus.
 * Mysil	2016-04-19
 */
typedef union					/* Task queue transfer request entry */
{	struct
	{	uint16_t	Address;		/* Bits <10:1> are the 10 bit address.	*/
									/* Bits <7:1> are the 7 bit address		*/
									/* Bit  <0> is R/W (1 for read)			*/
									/* Bits <15:11> are used for options.   */
		uint8_t		Length;			/* Number of bytes to be transferred  . */
		uint8_t		count;			// a count of trb's in the trb list,
									// maybe change to option,
									// queue entries linked together
		I2C_MESSAGE_STATUS	*pStatus;	/* Pointer to User Status word */
									/* set with the status of the current task. */
									/* When last transfer is successfull,
									 * this is I2C_MESSAGE_COMPLETE. */
		uint8_t    *pBuffer;        // pointer to buffer of length bytes
	};
	struct
	{	unsigned	:1;				/* R/W bit is here. */
  #ifdef	__XC8
		unsigned	:7;				/* Bitfield crossing byte boundary not allowed. */
		unsigned	:3;
  #else
		unsigned	Address10:10;	/* Bits <10:1> are the 10 bit address. */
  #endif
		unsigned	Options:5;		/* Option Flags, when task is complete, these are cleared. */
		uint16_t	Size;			/* 16 bit Length field overwriting count. */
		uint16_t	uStatusPtr;		/* placeholder, Pointer to User Status word */

      #if (I2C_TASK_QUEUE_LENGTH > 1)
		uint8_t 	Data[4];		/* Immediate storage for up to 4 bytes. */
	  #endif
	};
	struct
	{	unsigned	R_W:1;			/* Bit <0> is R/W bit (1 for read) */
		unsigned	Address7:7;		/* Bits <7:1> are the 7 bit address */
		unsigned	Address3:3;		/* Bits <10:8> 3 high bits of 10 bit address. */
		unsigned	Aflag:1;		/* Bit <11> =1 Master send 10 bit address.*/
		unsigned	Lflag:1;		/* Bit <12> =1 Request is Linked. */
		unsigned	Eflag:1;		/* Bit <13> =1 Big end of Command first. */
		unsigned	Iflag:1;		/* Bit <14> =1 Immediate Data[4] mode */
		unsigned	Bflag:1;		/* Bit <15> =1 Buffer mode flag. */
		uint16_t	L;
		uint16_t	uStatusPtr2;		/* Dummy, Pointer to User Status word */
	  #if (I2C_TASK_QUEUE_LENGTH > 1)
		uint32_t	Command;		/* Up to 32 bits to be transmitted. */
	  #endif
	};
} I2C_TASK;

/** ****************************************************************************
  I2C Master Driver Object Type

  @Summary
	Defines the object that manages the i2c master.

  @Description
	This defines the object that manages the sending and receiving of
	i2c master transactions.
 */
typedef union
{	volatile struct
    {   unsigned	full	:1;
        unsigned	empty	:1;
        unsigned	reserved:5;
		unsigned	WriteCollision	:1;
		unsigned	BusCollision	:1;
		unsigned	BclStart		:1;
		unsigned	BclAddress		:1;
		unsigned	BclData			:1;
		unsigned	BclIdle			:1;
		unsigned	AddressNACK 	:1;
		unsigned	DataNACK		:1;
		unsigned	LostState		:1;
    };
	struct
	{   uint8_t		Status;				/* Status of the queue. */
	    uint8_t 	Flags;				/* Error flags. */
	    uint8_t		i2cDoneFlag;		/* flag to indicate the current
										 * transaction is done. */
		uint8_t		Errors;				/* Counter keeps track of errors. */
    /* Read/Write Queue */
    I2C_TASK       *pHead;				/* pointer to head of the queue. */
    I2C_TASK       *pTail;				/* pointer to tail of the queue.*/
	};
} I2C_OBJECT;

/** ****************************************************************************
  I2C Master Driver State Enumeration

  @Summary
	Defines the different states of the i2c master.

  @Description
	This defines the different states that the i2c master
	used to process transactions on the i2c bus.
 */
typedef enum
{	S_MASTER_INIT,
	S_MASTER_IDLE,
	S_MASTER_START,
	S_MASTER_RESTART,
	S_MASTER_SEND_ADDR,
	S_MASTER_CHECK_ADDR,
	S_MASTER_SEND_DATA,
	S_MASTER_SEND_STOP,
	S_MASTER_ACK_ADDR,
	S_MASTER_RCV_DATA,
	S_MASTER_RCV_STOP,
	S_MASTER_ACK_RCV_DATA,
	S_MASTER_NOACK_STOP,
	S_MASTER_SEND_ADDR_10BIT_LSB,
	S_MASTER_10BIT_RESTART,
	S_MASTER_COMPLETED,
} I2C_MASTER_STATES;

/** ****************************************************************************
 *	Section: Macro Definitions
 */
#if     I2C_INSTANCE == 1
/* Function name mapping defined for I2C1 Master. */
  #define	I2Cx_MasterWrite(d,l,a,s)			I2C1_MasterWrite(d,l,a,s)
  #define	I2Cx_MasterCommandWrite(c,w,l,a,s)	I2C1_MasterCommandWrite(c,w,l,a,s)
  #define	I2Cx_MasterWriteRead(w,n,r,l,a,s)	I2C1_MasterWriteRead(w,n,r,l,a,s)
  #define	I2Cx_MasterCommandRead(c,r,l,a,s)	I2C1_MasterCommandRead(c,r,l,a,s)
  #define	I2Cx_MasterRead(r,l,a,s)			I2C1_MasterRead(r,l,a,s)

  #define	I2Cx_MasterReadTRBBuild(r,l,a,s)	I2C1_MasterReadTRBBuild (r,l,a,s)
  #define	I2Cx_MasterWriteTRBBuild(w,l,a,s)	I2C1_MasterWriteTRBBuild(w,l,a,s)
  #define	I2Cx_MasterTRBInsert(c,t,s)			I2C1_MasterTRBInsert(c,t,s)

#elif   I2C_INSTANCE == 2
/* Function name mapping defined for I2C2 Master. */
  #define	I2Cx_MasterWrite(d,l,a,s)			I2C2_MasterWrite(d,l,a,s)
  #define	I2Cx_MasterCommandWrite(c,w,l,a,s)	I2C2_MasterCommandWrite(c,w,l,a,s)
  #define	I2Cx_MasterWriteRead(w,n,r,l,a,s)	I2C2_MasterWriteRead(w,n,r,l,a,s)
  #define	I2Cx_MasterCommandRead(c,r,l,a,s)	I2C2_MasterCommandRead(c,r,l,a,s)
  #define	I2Cx_MasterRead(r,l,a,s)			I2C2_MasterRead(r,l,a,s)

  #define	I2Cx_MasterReadTRBBuild(r,l,a,s)	I2C2_MasterReadTRBBuild (r,l,a,s)
  #define	I2Cx_MasterWriteTRBBuild(w,l,a,s)	I2C2_MasterWriteTRBBuild(w,l,a,s)
  #define	I2Cx_MasterTRBInsert(c,t,s)			I2C2_MasterTRBInsert(c,t,s)

#elif   I2C_INSTANCE == 5
/* Function name mapping defined for I2C5 Master. */
  #define	I2Cx_MasterWrite(d,l,a,s)			I2C5_MasterWrite(d,l,a,s)
  #define	I2Cx_MasterCommandWrite(c,w,l,a,s)	I2C5_MasterCommandWrite(c,w,l,a,s)
  #define	I2Cx_MasterWriteRead(w,n,r,l,a,s)	I2C5_MasterWriteRead(w,n,r,l,a,s)
  #define	I2Cx_MasterCommandRead(c,r,l,a,s)	I2C5_MasterCommandRead(c,r,l,a,s)
  #define	I2Cx_MasterRead(r,l,a,s)			I2C5_MasterRead(r,l,a,s)

  #define	I2Cx_MasterReadTRBBuild(r,l,a,s)	I2C5_MasterReadTRBBuild (r,l,a,s)
  #define	I2Cx_MasterWriteTRBBuild(w,l,a,s)	I2C5_MasterWriteTRBBuild(w,l,a,s)
  #define	I2Cx_MasterTRBInsert(c,t,s)			I2C5_MasterTRBInsert(c,t,s)
#endif

/* Following register defines are only used inside this Driver source file I2Cx_MasterSlave.c */
#if     I2C_CHANNEL == 1
  #define	I2CxCONTROL				I2C1CON		// ${data.getRegisterByAlias("I2CCON").name}			/* I2C Control register */
  #define	I2CxSTAT				I2C1STAT	// ${data.getRegisterByAlias("I2CCON").name}			/* I2C Status register */
  #define	I2CxTRN					I2C1TRN		// ${data.getRegisterByAlias("I2CTRN").name}	/* Transmit	*/
  #define	I2CxRCV					I2C1RCV		// ${data.getRegisterByAlias("I2CRCV").name}	/* Receive register of I2C peripheral */
  #define	I2CxMSK					I2C1MSK 	// ${data.getRegisterByAlias("I2CMSK").name}
  #define	I2CxADD					I2C1ADD		// ${data.getRegisterByAlias("I2CADD").name}
  #define	I2CxBRG					I2C1BRG 	// ${data.getRegisterByAlias("I2CBRG").name}

// Translations for control register bitfield struct.
  #define	I2CxSTATbits			I2C1STATbits			// I2C Status register.
  #define	I2CxCONbits 			I2C1CONbits				// I2C Control register.

/*	Interrupt Flag register bit Macro definitions, local within this driver instance file. */
  #ifdef	__PIC32MX__
	#define	I2C_BUS_IRQ				_I2C1_BUS_IRQ
	#define	I2C_SLAVE_IRQ			_I2C1_SLAVE_IRQ
	#define	I2C_MASTER_IRQ			_I2C1_MASTER_IRQ
	#define	I2C_X_VECTOR			_I2C_1_VECTOR

	#define I2C_MasterInterruptFlag		IFS1bits.I2C1MIF
	#define I2C_MasterInterruptSET  	IFS1SET = _IFS1_I2C1MIF_MASK		/* Set Master interrupt flag */
	#define I2C_MasterInterruptCLR  	IFS1CLR = _IFS1_I2C1MIF_MASK		/* Clear master interrupt flag */
	#define I2C_MasterInterruptEnable	IEC1SET = _IEC1_I2C1MIE_MASK		/* enable the master interrupt */
	#define I2C_SlaveInterruptFlag  	IFS1bits.I2C1SIF
	#define I2C_SlaveInterruptSET		IFS1SET = _IFS1_I2C1SIF_MASK		/* Set Master interrupt flag */
	#define I2C_SlaveInterruptCLR		IFS1CLR = _IFS1_I2C1SIF_MASK		/* Clear master interrupt flag */
	#define I2C_SlaveInterruptEnable	IEC1SET = _IEC1_I2C1SIE_MASK		/* enable the master interrupt */
	#define I2C_BCLInterruptFlag		IFS1bits.I2C1BIF
	#define I2C_BCLInterruptSET 		IFS1SET = _IFS1_I2C1BIF_MASK		/* Set Bus collision Interrupt Flag */
	#define I2C_BCLInterruptCLR 		IFS1CLR = _IFS1_I2C1BIF_MASK		/* Clear Bus collision interrupt flag */
	#define I2C_BCLInterruptEnable  	IEC1SET = _IEC1_I2C1BIE_MASK		/* enable bus collision interrupt */
  #else
	#define	I2C_MasterInterruptFlag		IFS1bits.MI2C1IF
	#define I2C_MasterInterruptSET  	IFS1bits.MI2C1IF = 1
	#define I2C_MasterInterruptCLR  	IFS1bits.MI2C1IF = 0
	#define I2C_MasterInterruptEnable	IEC1bits.MI2C1IE = 1		/* enable the master interrupt */
	#define	I2C_SlaveInterruptFlag		IFS1bits.SI2C1IF
	#define I2C_SlaveInterruptSET   	IFS1bits.SI2C1IF = 1
	#define I2C_SlaveInterruptCLR   	IFS1bits.SI2C1IF = 0
	#define I2C_SlaveInterruptEnable	IEC1bits.SI2C1IE = 1		/* enable the master interrupt */
  #endif

#elif   I2C_CHANNEL == 2
  #define	I2CxCONTROL				I2C2CON		// ${data.getRegisterByAlias("I2CCON").name}			/* I2C Control register */
  #define	I2CxSTAT				I2C2STAT	// ${data.getRegisterByAlias("I2CCON").name}			/* I2C Status register */
  #define	I2CxTRN					I2C2TRN		// ${data.getRegisterByAlias("I2CTRN").name}	/* Transmit	*/
  #define	I2CxRCV					I2C2RCV		// ${data.getRegisterByAlias("I2CRCV").name}	/* Receive register of I2C peripheral */
  #define	I2CxMSK					I2C2MSK 	// ${data.getRegisterByAlias("I2CMSK").name}
  #define	I2CxADD					I2C2ADD		// ${data.getRegisterByAlias("I2CADD").name}
  #define	I2CxBRG					I2C2BRG 	// ${data.getRegisterByAlias("I2CBRG").name}

// Translations for control register bitfield struct.
  #define	I2CxSTATbits			I2C2STATbits			// I2C Status register.
  #define	I2CxCONbits 			I2C2CONbits				// I2C Control register.

/*	Interrupt Flag register bit Macro definitions, local within each driver instance file. */
  #ifdef	__PIC32MX__
	#define	I2C_BUS_IRQ				_I2C2_BUS_IRQ
	#define	I2C_SLAVE_IRQ			_I2C2_SLAVE_IRQ
	#define	I2C_MASTER_IRQ			_I2C2_MASTER_IRQ

	#define I2C_MasterInterruptFlag 	IFS1bits.I2C2MIF
	#define I2C_MasterInterruptSET  	IFS1SET = _IFS1_I2C2MIF_MASK		/* Set Master interrupt flag */
	#define I2C_MasterInterruptCLR  	IFS1CLR = _IFS1_I2C2MIF_MASK		/* Clear master interrupt flag */
	#define I2C_MasterInterruptEnable	IEC1SET = _IEC1_I2C2MIE_MASK		/* enable the master interrupt */
	#define I2C_SlaveInterruptFlag  	IFS1bits.I2C2SIF
	#define I2C_SlaveInterruptSET		IFS1SET = _IFS1_I2C2SIF_MASK		/* Set Master interrupt flag */
	#define I2C_SlaveInterruptCLR		IFS1CLR = _IFS1_I2C2SIF_MASK		/* Clear master interrupt flag */
	#define I2C_SlaveInterruptEnable	IEC1SET = _IEC1_I2C2SIE_MASK		/* enable the master interrupt */
	#define I2C_BCLInterruptFlag		IFS1bits.I2C2BIF
	#define I2C_BCLInterruptSET 		IFS1SET = _IFS1_I2C2BIF_MASK		/* Set Bus collision Interrupt Flag */
	#define I2C_BCLInterruptCLR 		IFS1CLR = _IFS1_I2C2BIF_MASK		/* Clear Bus collision interrupt flag */
	#define I2C_BCLInterruptEnable  	IEC1SET = _IEC1_I2C2BIE_MASK		/* enable bus collision interrupt */
  #else
	#define	I2C_MasterInterruptFlag		IFS3bits.MI2C2IF
	#define I2C_MasterInterruptSET  	IFS3bits.MI2C2IF = 1
	#define I2C_MasterInterruptCLR  	IFS3bits.MI2C2IF = 0
	#define I2C_MasterInterruptEnable	IEC3bits.MI2C2IE = 1		/* enable the master interrupt */
	#define	I2C_SlaveInterruptFlag		IFS3bits.SI2C2IF
	#define I2C_SlaveInterruptSET   	IFS3bits.SI2C2IF = 1
	#define I2C_SlaveInterruptCLR   	IFS3bits.SI2C2IF = 0
	#define I2C_SlaveInterruptEnable	IEC3bits.SI2C2IE = 1		/* enable the master interrupt */
  #endif

  #define		I2C_X_VECTOR	   _I2C_2_VECTOR
#elif   I2C_CHANNEL == 5
  #warning "I2C Macros not defined for this channel."
  #define		I2C_X_VECTOR	   _I2C_5_VECTOR
#else
  #warning "I2C Macros not defined for this channel."
#endif

/** ****************************************************************************
 *	Section: Module Variables
 */
static int CollisionCount, RetryCount;
unsigned int	I2C_Wait,	I2C_Timeout;	/* This is intended, 16 bit on 8 bit and 16 bit devices, 32 bit on PIC32 */

/*	Transfer task data */
#ifdef  __DEBUG					/* Debug configuration with Global objects for easier debugging,
								 * may cause name conflicts with multiple driver instances. */
		I2C_TASK			I2C_Task[I2C_TASK_QUEUE_LENGTH];
		I2C_OBJECT			I2C_Queue;	// = {  .pHead = &I2C_Task[0],
										//		.pTail = &I2C_Task[0]};
		I2C_TASK		   *pI2C_Current = NULL;
volatile
		I2C_MASTER_STATES	I2C_State = S_MASTER_IDLE;
		uint8_t				Multimaster   = 1;
static	I2C_MESSAGE_STATUS	CompletionCode;
		uint8_t				AddressHigh;	//, AddressLow;
		uint16_t			Address10;
#else							/* Module variables and objects all static */
static	I2C_TASK			I2C_Task[I2C_TASK_QUEUE_LENGTH];
static	I2C_OBJECT			I2C_Queue;	// = { .pHead = &I2C_Task[0],
										//     .pTail = &I2C_Task[0]};
static	I2C_TASK		   *pI2C_Current = NULL;
static volatile
		I2C_MASTER_STATES	I2C_State = S_MASTER_IDLE;
static	uint8_t				Multimaster   = 1;
static	I2C_MESSAGE_STATUS	CompletionCode;
static	uint8_t				AddressHigh;	//, AddressLow;
static	uint16_t			Address10;
#endif

/** ****************************************************************************
 *	Section: Local Functions
 */
static inline void I2C_FunctionComplete (I2C_MESSAGE_STATUS completion_code);
static inline void I2C_Stop (I2C_MESSAGE_STATUS completion_code);
static inline void I2C_Check (void);
static inline unsigned int	I2C_Timer(void);
/** ****************************************************************************
 *	Internal function to reserve Task queue entry and advance Tail pointer.
 *	Argument count, if (count > 1)
 *	function will check that sufficient task queue entries are available.
 *	Only 1 entry will be reserved, and pointer returned as function value.
 */
static inline I2C_TASK *
I2C_TaskReserve(uint8_t count)		/* Number of Task queue entries needed. */
{
	I2C_TASK	*pTask;
	// check if there is space in the queue
	if (I2C_Queue.full)
		return NULL;			/* Unsuccessfull return. */

	if ( count > 1)				/* If linking of Task queue entries, check that all entries may be entered. */
	{	if (count > I2C_TASK_QUEUE_LENGTH)
			return NULL;
		else if(I2C_Queue.pTail >= I2C_Queue.pHead)
		{	if((I2C_Queue.pTail + count) > (I2C_Queue.pHead + I2C_TASK_QUEUE_LENGTH))
				return NULL;
		}
		else
		{	if((I2C_Queue.pTail + count) > I2C_Queue.pHead)
				return NULL;
		}
	}

	if (I2C_Queue.pTail->Options != 0)	/* Check that previous Task using the same entry is complete. */
		__builtin_software_breakpoint();/* Hang here for debugging. */
	pTask = I2C_Queue.pTail;			/* Copy pointer to a local. */
	I2C_Queue.pTail++;					/* Add to the tail. */

	// check if the end of the array is reached
	if (I2C_Queue.pTail == (I2C_Task + I2C_TASK_QUEUE_LENGTH))
	{
		// adjust to restart at the beginning of the array
		I2C_Queue.pTail = I2C_Task;	/* This should be the first entry. */
		I2C_Queue.pTail = &I2C_Task[0];
	}

	// since we added one item to be processed, we know
	// it is not empty, so set the empty status to false
	I2C_Queue.empty = false;

	// check if full
	if (I2C_Queue.pHead == I2C_Queue.pTail)
	{
		// it is full, set the full status to true
		I2C_Queue.full = true;
	}
	return pTask;
}
/*******************************************************************************
 *	Internal function to release Task queue entry and advance Head pointer.
 */
static inline
void I2C_TaskRelease (I2C_TASK * pTask)
{
	/* If argument pTask is not pointing to queue head, we have lost track of the task sequence. */
	if ( pTask != I2C_Queue.pHead)
		__builtin_software_breakpoint();		/* Hang here for debugging. */

	I2C_Queue.pHead++;					/* Advance the head pointer. */
										/* Check if end of the array is reached. */
	if (I2C_Queue.pHead == (I2C_Task + I2C_TASK_QUEUE_LENGTH))
	{
										/* Point to start of the array. */
		I2C_Queue.pHead = I2C_Task;	/* This should be the first entry. */
		I2C_Queue.pHead = &I2C_Task[0];	/* This should be the same. */
	}
										/* Since we have advanced the Head pointer, . */
	I2C_Queue.full = false;			/* Queue is Not full. */
	if (I2C_Queue.pHead == I2C_Queue.pTail)
		I2C_Queue.empty = true;
}

/** ****************************************************************************
 *	Section: Driver Interface Functions
 */
/** ****************************************************************************
 *	I2Cx_Initialize()
 */
#ifndef I2C_INSTANCE
void	I2C_Initialize(void)
#elif I2C_INSTANCE == 0
void	I2C_Initialize(void)
#elif I2C_INSTANCE == 1
void	I2C1_Initialize(void)
#elif I2C_INSTANCE == 2
void	I2C2_Initialize(void)
#elif I2C_INSTANCE == 3
void	I2C3_Initialize(void)
#elif I2C_INSTANCE == 4
void	I2C4_Initialize(void)
#elif I2C_INSTANCE == 5
void	I2C5_Initialize(void)
#endif
{
	I2C_TASK	*pTask;

	/* Initialize Task queue. */
	I2C_Queue.pHead = &I2C_Task[0];
	I2C_Queue.pTail = &I2C_Task[0];
	I2C_Queue.Status = 0;
	I2C_Queue.empty = true;
	I2C_Queue.full  = false;
	I2C_Queue.Flags = 0;
	I2C_Queue.LostState = 0;
	I2C_Queue.WriteCollision = 0;
	I2C_Queue.Errors = 0;

    /* Place the Task state machine in its initial state. */
	I2C_State = S_MASTER_IDLE;
//	I2C_State  = S_MASTER_INIT; I2C_S_Init;

	/* Initialize all task queue entries. */
	pTask = I2C_Task;					/* This should be the first entry. */
	while (pTask < (I2C_Task + I2C_TASK_QUEUE_LENGTH))
	{	pTask->Address = 0;
		pTask->Options = 0;
		pTask++;
	}

	// initialize the hardware
	// Baud Rate Generator Value: I2CBRG 39;
	// Calculated Frequency: 99ï¿½010 Hz		I2C5BRG = 0x0027;
	I2CxBRG = 395;		/* Baudrate divider for PIC32MX with 80 MHz clock.  */

	I2CxBRG = 384;		/* Adjusted for 4.7 kOhm pull-up, 60 cm wiring,
						 * SlewRate control Disabled, giving 100.2 kHz,
						 * calculated capacitance 115 pF */
	I2CxBRG = 384;		/* With SlewRate control Enabled: 100.0 kHz */
	I2CxBRG = (_XTAL_FREQ / I2C_FREQ / 2) - 2;

	// ACKEN disabled; STREN disabled; GCEN disabled; SMEN disabled; DISSLW enabled; I2CSIDL disabled; ACKDT Sends ACK; SCLREL Holds; RSEN disabled; IPMIEN disabled; A10M 7 Bit; PEN disabled; RCEN disabled; SEN disabled; I2CEN enabled; 
//	I2C5CON = 0x8000;
//	I2CxCONTROL =	_I2C1CON_ON_MASK		/* Wait until setup is complete. */
	I2CxCONTROL =	_I2C1CON_DISSLW_MASK	/* 0 means Slew Rate control is enabled. */
			//	|	_I2C1CON_STREN_MASK		/* Clock Stretching Enabled. */
			//	|	_I2C1CON_STRICT_MASK	/* No response to Reserved addresses. This bit is different on PIC24 */
				|	_I2C1CON_SMEN_MASK;		/* SMbus signal detection levels. */
			//	|	_I2C1CON_GCEN_MASK;		/* General Call enable. */
	/* Comments created by MCC are confusing and misleading:
	 * This file is I2C Master code: STREN is relevant in Slave code only!
	 * SCLREL is used in Slave operation only.
	 * GCEN used in Slave operatiions only.
	 * ACKDT will need to be controlled when receiving data, according to state of the transfer.
	 * SEN, PEN, RSEN, RCEN and ACKEN are control bits for actions to be performed by hardware,
	 * They shall all be Clear when I2C hardware is enabled, they are not disabled. RTFM. */

	// P disabled; S disabled; BCL disabled; I2COV disabled; IWCOL disabled;
	I2CxSTAT = 0x0000;
	/* Comments generated by MCC are confused and misleading:
	 * P is not disabled by this initialization code:
	 * P is a bit that is controlled by hardware.
	 * it is cleared by the hardware when I2C module is not enabled,
	 * and is initially clear when I2C is enabled.
	 * S bit same as P, also controlled by hardware.
	 * There is some conflicting information around:
	 * PIC32MX7xx datasheet DS61156H Register 18_2: R/C,HSC  Readable, Clearable, Hardware set/cleared
	 * PIC32 FRM24          DS61116F Register 24_2: R/W-0 for P and S bits.
	 * BCL bit cannot be disabled:
	 * It is a Status bit that is Set by Hardware when a signal collision is detected,
	 * it will need to be cleared by software before operations may be continued.
	 * Same for IWCOL and I2COV. RTFM */

	I2C_Timeout = I2C_Timer();		/* Set Timeout Start time. */

								/* Check that I2C signal lines are Not Jammed */
	I2C_Check();

	/* MI2C5 - I2C5 Master Events */
#ifdef __PIC32MX
	I2CxCONbits.ON = 1;				/* Now enable the module. */
	I2C_BCLInterruptCLR;		//	IFS1CLR	 =	_IFS1_I2C1BIF_MASK;	/* Clear Interrupt Flags before enabling interrupts. */
	I2C_MasterInterruptCLR;		//	IFS1CLR  =	_IFS1_I2C1MIF_MASK;
																	/* For MCC, Configure interrupt priority in interrupt manager module to override this. */
//	IPC9CLR  =		_IPC9_I2C2IP_MASK;		/* Clear interrupt priority field. */
//	IPC9SET = I2C_PRIORITY << _IPC9_I2C2IP_POSITION;	/* Interrupt Priority. */
	*(&IPC0CLR + (I2C_X_VECTOR / 4) * 4) = 0x1F << ((I2C_X_VECTOR & 0x03) * 8);
														/* Interrupt Priority. */
	*(&IPC0SET + (I2C_X_VECTOR / 4) * 4) = (I2C_PRIORITY * 4) << ((I2C_X_VECTOR & 0x03) * 8);
	*(&IPC0SET + (I2C_X_VECTOR / 4) * 4) = (I2C_CHANNEL & 3) << ((I2C_X_VECTOR & 0x03) * 8);

	I2C_BCLInterruptEnable;		//	IEC1SET  =		_IEC1_I2C2BIE_MASK;
	I2C_MasterInterruptEnable;	//	IEC1SET  =		_IEC1_I2C2MIE_MASK;
#else
	I2CxCONbits.I2CEN = 1;				/* Now enable the module. */
	// clear the master interrupt flag
	I2C_MasterInterruptCLR;		//	IFS3bits.MI2C5IF = 0;
	// enable the master interrupt
	I2C_MasterInterruptEnable;	//	IEC3bits.MI2C5IE = 1;
#endif
}

/*******************************************************************************
 *	Write buffer to I2C Slave */
void I2Cx_MasterWrite(	uint8_t *pData,			/* Buffer pointer */
						uint8_t  Length,		/* Transfer length */
						uint16_t Address,		/* I2C Slave address */
			 I2C_MESSAGE_STATUS *pStatus)		/* Pointer to Status */
{
	I2C_MESSAGE_STATUS options = *pStatus;
	I2C_TASK	*pTask;

	if (*pStatus >= I2C_MESSAGE_COMPLETE)
		*pStatus = I2C_MESSAGE_START;

	pTask = I2C_TaskReserve(1);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	*pStatus = I2C_MESSAGE_QUEUE_FULL;
		return;	}
										/* Decode options in Address argument ? or just insert everything including flags. */
	pTask->Address = Address << 1 & 0x07FE;	/* Shift into 8 bit address, Mask with 0x07FE ? */
	pTask->R_W = 0;						/* Master Write transfer */
	pTask->Length = Length;				/* Transfer length */
	pTask->pBuffer = pData;				/* Pointer to User's Buffer */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_TASK_LINK)		/* Linking option in Address argument. */
		pTask->Lflag = 1;				/* Chaining option. */
	pTask->Bflag = 1;					/* Transfer from User's Buffer. */
	*pStatus = I2C_MESSAGE_PENDING;

										/* Test for interrupt based wakeup call. */
	if (I2C_State == S_MASTER_IDLE)	/* Check I2C hardware status and make a wakeup call if needed. */
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	else
	if (I2C_State == S_MASTER_COMPLETED)
	{	while (I2CxCONTROL & 0b00011111)	/* Check that I2C operation is completed. */
			Nop();						/* Should Not happen, will be checked in ISR. */
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	}
										/* If Blocking option set in argument */
	if (options & I2C_OPTION_BLOCKING)	/* Stall here while task driver work. */
		while (*pStatus < I2C_MESSAGE_COMPLETE)
			Nop();
	return;
}

  #if (I2C_TASK_QUEUE_LENGTH > 1)
/*******************************************************************************
 * 	Combined operation:
 *	Start, AddressW, Write command, Write data, Stop
 */
void I2Cx_MasterCommandWrite(	uint32_t Command,	/* Command value */
								uint8_t *pData,		/* Buffer pointer */
								uint8_t  Length,	/* Transfer length */
								uint16_t Address,	/* I2C Slave address */
					 I2C_MESSAGE_STATUS *pStatus)	/* Pointer to User Status */
{
	I2C_MESSAGE_STATUS options = *pStatus;
	I2C_TASK * pTask;

	if (*pStatus >= I2C_MESSAGE_PENDING)
	{	*pStatus = I2C_MESSAGE_START;
		options = I2C_OPTION_COMMAND1;
	}
	pTask = I2C_TaskReserve(2);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	*pStatus = I2C_MESSAGE_QUEUE_FULL;
		return;	}
										/* First part of Transfer Request. */
	pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address. &0x07FE */
	pTask->R_W = 0;						/* Write transfer. */
	pTask->Command = Command;			/* Immediate Command data */
	pTask->Length  = options & 0x07;	/* Transfer length */
	pTask->Lflag = 1;					/* Chaining option. */
	if (Length == 0)
		pTask->Lflag = 0;				/* Special case Length == 0; */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;
	if (options & I2C_OPTION_BIGEND)
		pTask->Eflag = 1;				/* Transfer MSB first. */
	else
		pTask->Eflag = 0;				/* Transfer first byte first. */
	if (pTask->Length == 0)
		pTask->Length = 1;				/* Default 1 byte command. */
	pTask->Iflag = 1;					/* Data value in Task queue entry Data. */
										/* Iflag is the last item to be set in this queue entry, Task driver will check this bit before processing this task. */
										/* Second part of Transfer Request. */
	if (Length)							/* Skip if Length is zero. */
	{	pTask = I2C_TaskReserve(1);			/* Allocate Queue Entry. */
		if (pTask == NULL)					/* Check pointer. */
		{	__builtin_software_breakpoint();/* Error here cannot be recovered, must be prevented in I2C_TaskReserve(2) above. */
			*pStatus = I2C_MESSAGE_QUEUE_FULL;
			return;
		}
		pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address */
		pTask->pBuffer = pData;				/* Buffer pointer */
		pTask->Length = Length;				/* Transfer length */
		pTask->pStatus = pStatus;			/* Pointer to application Status */
		if (Address & 0x380)				/* Address in 10-bit range */
			pTask->Aflag = 1;
		if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
			pTask->Aflag = 1;
		if (Address & I2C_TASK_LINK)		/* Linking option in Address argument. */
			pTask->Lflag = 1;				/* Chaining option. */
		pTask->Bflag = 1;					/* Use pointer to User's buffer */
	}
	*pStatus = I2C_MESSAGE_PENDING;

										/* Test for interrupt based wakeup call */
	if (I2C_State == S_MASTER_IDLE)	/* Check I2C hardware status and make a wakeup call if needed. */
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	else								/* Check that I2C operation is completed. */
	if (I2C_State == S_MASTER_COMPLETED)
	{	while (I2CxCONTROL & 0b00011111)	/* May not be needed, will be checked in ISR. */
			Nop();
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	}
										/* If Blocking option set in argument */
	if (options & I2C_OPTION_BLOCKING)	/* Stall here until transfer is done. */
		while (*pStatus < I2C_MESSAGE_COMPLETE)
			Nop();
	return;
}

/*******************************************************************************
 * 	Combined operation:
 *	Start, AddressW, Write data, Restart, AddressR, Read data, Stop */
void I2Cx_MasterWriteRead(	uint8_t *pWriteData,	/* Write buffer pointer */
							uint8_t  WriteLength,	/* Transfer length */
				volatile	uint8_t *pReadData,		/* Read buffer pointer */
							uint8_t  ReadLength,	/* Transfer length */
							uint16_t Address,		/* I2C Slave address */
				 I2C_MESSAGE_STATUS *pStatus)		/* Pointer to Status */
{
	I2C_MESSAGE_STATUS options = *pStatus;
	I2C_TASK	*pTask;

	if (*pStatus >= I2C_MESSAGE_COMPLETE)
		*pStatus = I2C_MESSAGE_START;

	pTask = I2C_TaskReserve(2);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	*pStatus = I2C_MESSAGE_QUEUE_FULL;
		return;	}
										/* First part of Transfer Request. */
	pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address */
	pTask->R_W = 0;						/* Write transfer. */
	pTask->pBuffer = pWriteData;		/* Pointer to User's Buffer */
	pTask->Length = WriteLength;		/* Write Transfer length */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	pTask->Lflag = 1;					/* Chaining option. */
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;				/* Flag for 10 bit address */
	pTask->Eflag = 0;					/* Transfer first byte first. */
	pTask->Bflag = 1;					/* Data in User's buffer. */

										/* Second part of Transfer Request. */
	pTask = I2C_TaskReserve(1);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	__builtin_software_breakpoint();
		return;
	}
	pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address */
	pTask->R_W = 1;						/* Read transfer. */
	pTask->pBuffer = (uint8_t *)pReadData;	/* Pointer to User's Buffer */
	pTask->Length = ReadLength;			/* Transfer length */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;				/* Flag for 10 bit address */
	if (Address & I2C_TASK_LINK)		/* Linking option in Address argument. */
		pTask->Lflag = 1;				/* Chaining option. */
	pTask->Bflag = 1;					/* Flag for User's buffer */
	*pStatus = I2C_MESSAGE_PENDING;
										/* Test for interrupt based wakeup call */
	if (I2C_State == S_MASTER_IDLE)	/* Check I2C hardware status and make a wakeup call if needed. */
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	else								/* Check that I2C operation is completed. */
	if (I2C_State == S_MASTER_COMPLETED)
	{	while (I2CxCONTROL & 0b00011111)	/* May not be needed, will be checked in ISR. */
			Nop();
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	}

	if (options & I2C_OPTION_BLOCKING)
		while (*pStatus < I2C_MESSAGE_COMPLETE)
			Nop();
	return;
}

/*******************************************************************************
 * 	Combined operation:
 *	Start, AddressW, Write command, Restart, AddressR, Read data, Stop */
void I2Cx_MasterCommandRead(uint32_t Command,	/* Command value */
				volatile	uint8_t *pData,		/* Buffer pointer */
							uint8_t  Length,	/* Transfer length */
							uint16_t Address,	/* I2C Slave address */
				 I2C_MESSAGE_STATUS *pStatus)	/* Pointer to Status */
{
	I2C_MESSAGE_STATUS options = *pStatus;
	I2C_TASK	*pTask;

	/* Use of *pStatus is risky if same target is reused for queued transfer requests. */
	if (*pStatus >= I2C_MESSAGE_COMPLETE)
		*pStatus = I2C_MESSAGE_START;

	pTask = I2C_TaskReserve(2);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	*pStatus = I2C_MESSAGE_QUEUE_FULL;
		return;	}						/* First part of Transfer Request. */
	pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address */
	pTask->R_W = 0;						/* Write transfer. */
	pTask->Command = Command;			/* Immediate Command data */
	pTask->Length = *pStatus & 0x07;	/* Transfer length */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	pTask->Lflag = 1;					/* Chaining option. */
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;				/* Flag for 10 bit address */
	if (options & I2C_OPTION_BIGEND)
		pTask->Eflag = 1;				/* Transfer MSB first. */
	else
		pTask->Eflag = 0;				/* Transfer first byte first. */
	if (pTask->Length == 0)
		pTask->Length = 1;				/* Default 1 byte command. */
	pTask->Iflag = 1;					/* Data value in TR Data. */

										/* Second part of Transfer Request. */
	pTask = I2C_TaskReserve(1);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	__builtin_software_breakpoint();
		return;	}
	pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address */
	pTask->R_W = 1;						/* Read transfer. */
	pTask->pBuffer = (uint8_t *)pData;	/* Pointer to User's Buffer */
	pTask->Length = Length;				/* Transfer length */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;				/* Flag for 10 bit address */
	if (Address & I2C_TASK_LINK)		/* Linking option in Address argument. */
		pTask->Lflag = 1;
	pTask->Bflag = 1;					/* Flag for User's buffer */
	*pStatus = I2C_MESSAGE_PENDING;

										/* Test for interrupt based wakeup call */
	if (I2C_State == S_MASTER_IDLE)	/* Check I2C hardware status and make a wakeup call if needed. */
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	else								/* Check that I2C operation is completed. */
	if (I2C_State == S_MASTER_COMPLETED)
	{	while (I2CxCONTROL & 0b00011111)	/* May not be needed, will be checked in ISR. */
			Nop();
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	}
										/* If Blocking flag was set in argument options. */
	if (options & I2C_OPTION_BLOCKING)	/* Stall until complete, or failed. */
		while (*pStatus < I2C_MESSAGE_COMPLETE)
			Nop();
	return;
}
  #endif	// #if (I2C_TASK_QUEUE_LENGTH > 1)

void I2Cx_MasterRead(
			volatile	uint8_t *pData,			/* Buffer pointer */
						uint8_t  Length,		/* Transfer length */
						uint16_t Address,		/* I2C Slave address */
			 I2C_MESSAGE_STATUS *pStatus)		/* Pointer to Status */
{
	I2C_MESSAGE_STATUS options = *pStatus;
	I2C_TASK	*pTask;
//	BSP_TIME_DEBUG_SET;

	if (*pStatus >= I2C_MESSAGE_COMPLETE)
		*pStatus = I2C_MESSAGE_START;

	pTask = I2C_TaskReserve(1);		/* Allocate Queue Entry. */
	if (pTask == NULL)					/* Check pointer. */
	{	*pStatus = I2C_MESSAGE_QUEUE_FULL;
		return;	}

	pTask->Address = Address << 1 & 0x7FE;	/* Shift into 8 bit address */
	pTask->R_W = 1;						/* Read transfer. */
	pTask->Length  = Length;			/* Transfer length */
	pTask->pBuffer = (uint8_t *)pData;	/* Pointer to User's buffer. */
	pTask->pStatus = pStatus;			/* Pointer to application Status */
	if (Address & 0x380)				/* Address in 10-bit range */
		pTask->Aflag = 1;
	if (Address & I2C_ADDRESS_10)		/* 10-bit address option in Address argument. */
		pTask->Aflag = 1;				/* Flag for 10 bit address */
	if (Address & I2C_TASK_LINK)		/* Linking option in Address argument. */
		pTask->Lflag = 1;
	pTask->Bflag = 1;					/* Use Pointer to User's buffer */
	*pStatus = I2C_MESSAGE_PENDING;
										/* Test for interrupt based */
	if (I2C_State == S_MASTER_IDLE)	/* Check I2C hardware status and make a wakeup call if needed. */
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	else								/* Check that I2C operation is completed, */
	if (I2C_State == S_MASTER_COMPLETED)
	{	while (I2CxCONTROL & 0b00011111)	/* may not be needed, will be checked in ISR. */
			Nop();
		I2C_MasterInterruptSET;			/* Trigger an Interrupt */
	}
	if (options & I2C_OPTION_BLOCKING)	/* Wait until finished. */
		while (*pStatus < I2C_MESSAGE_COMPLETE)
			Nop();
	return;
}

/** ****************************************************************************
 *	Function to return Error counter.
 */
uint8_t
I2C1_ErrorCountGet (I2C_ERROR_FLAGS * flags)
{
	uint8_t ret;

	ret = I2C_Queue.Errors;
	return ret;
}

/** ****************************************************************************
 *	Interrupt Handler for I2C Task Queue Driver
 */
#ifdef  __PIC32MX
void __attribute__((vector(I2C_X_VECTOR), interrupt(I2C_IPL), nomips16))
#else
void __attribute__ ((interrupt, no_auto_psv))
#endif
#if (I2C_CHANNEL == 1)
_MI2C1Interrupt(void)
#elif (I2C_CHANNEL == 2)
_MI2C2Interrupt(void)
#endif
{
	static volatile uint8_t *pi2c_buf_ptr;
	static uint16_t			 i2c_address;
	static uint8_t			 i2c_bytes_left;
	static uint8_t			 i2c_10bit_address_restart = 0;
	static uint8_t			 index = 0;			/* Index in immediate data. */
	static I2C_MESSAGE_STATUS *pI2C_Message;	/* Local pointer for current Application status. */

	DIAG_INT_H;							/* Timing measurement signal. */

	/* PIC24 I2C is able to perform both Master and Slave operations,
	 * there are separate interrupt flags for Master and Slave interrupts.
	 * This is Master interrupt handler, Slave is completely separate.
	 * There is no separate Bus Collision interrupt, so Bus Collision is handled here.
	 */

//  if (I2C_MasterInterruptFlag)			/* Master interrupt. */
//  {
	I2C_MasterInterruptCLR;

	/* Check special cases in Status register. */
	if (I2CxSTAT & (_I2C1STAT_TRSTAT_MASK | _I2C1STAT_BCL_MASK | _I2C1STAT_IWCOL_MASK))
		// Check first if there was a collision.
		// If we have a Write Collision, reset and go to idle state
		/* Write Collision should not happen, it is a result of bug in driver.
		 * If this driver had control of the bus before write collision,
		 * Stop condition signalling should be performed. */
	{	if (I2CxSTATbits.IWCOL)
		{
			// clear the Write collision
			I2CxSTATbits.IWCOL = 0;
			I2C_State = S_MASTER_IDLE;
			*(pI2C_Current->pStatus) = I2C_ERROR_FAIL;

			I2C_Queue.Errors ++;		/* Error counter */
			I2C_Queue.WriteCollision = 1;

			while (pI2C_Current->Lflag)		/* Linked transfer requests must be canceled on error conditions. */
			{	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
				pI2C_Current->Options = 0;	/* Clear flags */
				pI2C_Current = I2C_Queue.pHead;
			}
			if ( pI2C_Current != NULL)
			{	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
				pI2C_Current->Options = 0;	/* Clear flags */
			}
			// reset the buffer pointer
			pI2C_Current = NULL;
			DIAG_INT_L;					/* Timing measurement signal. */
			return;
		}
		/***********************************************************************
		 *  If operation in Multimaster environment is Not expected, this may work.
		 */
//		if (I2CxSTATbits.BCL)			/* Clear the I2C Bus colision. */
//		{	I2CxSTATbits.BCL = 0;		/* I2C Bus collision will need different attention if Multimaster environment. */
//			if ( pI2C_Current != NULL)
//			*(pI2C_Current->pStatus) = I2C_MESSAGE_FAIL;
//			if ( pI2C_Current != NULL)
//			{	I2C_TaskRelease ( pI2C_Current); /* Task queue entry must be released. */
//				pI2C_Current->Options = 0;
//				pI2C_Current = NULL;		/* reset the queue entry pointer. */
//			}
//			I2C_State = S_MASTER_IDLE;	/*	Back to square 1, Idle State. */
//			DIAG_INT_L;					/* Timing measurement signal. */
//			return;
//		}
		/**********************************************************************/
		if (I2CxSTATbits.BCL)			/* Bus Collision or Arbitration lost. */
		{
			LED_RedON();				/* LED2 Red  On */
			I2C_Queue.Errors++;
			I2C_Queue.BusCollision = 1;
			CollisionCount ++;			/* Count to record if Bus Collisions
										 * happen for every transfer. */
			I2CxSTATbits.BCL = 0;		/* Clear Bus Collision Status. */
			I2CxSTAT &= ~_I2C1STAT_BCL_MASK;	/* Workaround for errata #5 on PIC33F...MCx02 */
			/* Check that Current pointer correspond to Queue head pointer. */
			if (pI2C_Current == NULL || pI2C_Current != I2C_Queue.pHead )
			{	pI2C_Current = NULL;
				if (I2CxSTATbits.BCL)				/* If Bus Collision bit still sticking. */
				{	I2CxCONbits.I2CEN = 0;			/* Disable the module. */
					Nop();	Nop();	Nop();
					I2CxCONbits.I2CEN = 1;			/* Enable again. */
				}
				if (I2C_Queue.empty)
				{	I2C_State = S_MASTER_IDLE;		/* Next state. */
						return;
				}
				else if (I2C_Queue.pHead->Options )	/* Seem to be a pending entry. */
				{		I2C_State = S_MASTER_IDLE;
			//		I2C_MasterInterruptSET;			/* Set interrupt flag to keep going. */
			//		return;
				}
			}

			/* Bus Collision during Start condition signalling,
			 * or during Address transmission should be retried. */
			if ((I2C_State == S_MASTER_START) ||
				(I2C_State == S_MASTER_SEND_ADDR) ||
				(I2C_State == S_MASTER_SEND_ADDR_10BIT_LSB) ||
				(I2C_State == S_MASTER_CHECK_ADDR) ||
				(I2C_State == S_MASTER_ACK_ADDR))
			{	RetryCount ++;
				if (I2C_State == S_MASTER_SEND_ADDR || I2C_State == S_MASTER_START)
					I2C_Queue.BclStart = 1;
				else
					I2C_Queue.BclAddress = 1;		/* Note the event. */
				if (I2CxSTATbits.BCL)				/* If Bus Collision bit still sticking. */
				{
					I2CxCONbits.I2CEN = 0;			/* Disable the module. */
					Nop();	Nop();	Nop();
					I2CxCONbits.I2CEN = 1;			/* Now enable the module. */
				}
				I2C_State = S_MASTER_START;
				*pI2C_Current->pStatus = I2C_MESSAGE_RETRY;
		//		I2C_MasterInterruptSET;			/* Set interrupt flag to get back. */
			}
			else if (I2C_State == S_MASTER_START || I2C_State == S_MASTER_IDLE)
			{	I2C_Queue.BclIdle = 1;			/* If state is Start or Idle, just try again. */
		//		I2C_MasterInterruptSET;			/* Set interrupt flag to get back. */
			}
			/* Bus Collision during Data transfer must be Failed and removed
			 * from the queue, including any linked queue entries. */
			else
			{	if (pI2C_Current->pStatus != NULL)	/* Update API status with the completion code. */
					*pI2C_Current->pStatus = I2C_ERROR_BCL;
				while (pI2C_Current->Lflag)		/* Linked transfer requests must be canceled on error conditions. */
				{	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
					pI2C_Current->Options = 0;	/* Clear flags */
					pI2C_Current = I2C_Queue.pHead;
				//	pI2C_Message = pI2C_Current->pStatus;
				}
				I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
				pI2C_Current->Options = 0;	/* Clear flags */
				pI2C_Current = NULL;
				/* Check that I2C signal lines are Not Jammed */
				/* If SDA or SCL is permanent Low, and S is not recorded, bus may have been jammed in a Reset condition. */
				I2CxCONbits.I2CEN = 0;	// = _I2C1CON_ON_MASK;	/* Disable the module. */
		//		I2C_Check();						/* If real Multimaster, this shouldn't be done. */
				I2CxCONbits.I2CEN = 1;	// = _I2C1CON_ON_MASK;	/* Now enable the module. */
				// Done, back to idle
				I2C_State = S_MASTER_IDLE;
		//		I2C_MasterInterruptSET;			/* Set interrupt flag to get back. */
			}
		}
		/**********************************************************************/
		if (I2CxSTATbits.TRSTAT)		/* Previous Transmit operation not completed, */
		{
			while (I2CxSTATbits.TRSTAT)	/* wait it out */
				Nop();
			I2C_MasterInterruptCLR;		/* Make sure Interrupt flag is cleared. */
	}	}

	/* Check that previous operation really is completed */
	if (I2CxCONTROL & 0b00011111)
	{
		if (I2CxCONbits.RCEN)				/* Read from Slave not yet complete */
		{	DIAG_INT_L;						/* Timing measurement signal. */
			return;
		}
		if (I2CxCONbits.PEN)				/* Stop signalling not yet complete */
		{	DIAG_INT_L;						/* Timing measurement signal. */
			return;
		}
		while (I2CxCONTROL & 0b00011111)	/* wait it out */
			Nop();
		I2C_MasterInterruptCLR;				/* Make sure Interrupt flag is cleared. */
	}

	/* Handle the correct i2c state */
	switch (I2C_State)
	{
	  case S_MASTER_COMPLETED:
		if (AddressHigh)				/* Workaround for 10-bit addressing. */
		{	I2CxCONbits.A10M = 1;		/* Enable 10-bit address detection again. */
			I2CxADD = Address10;		/* May need to fix content of Address register also. */
		}
		// Update Application status message with CompletionCode
		// Make sure the flag pointer is not NULL
		if (pI2C_Message != NULL)
		{	if ((I2C_Queue.empty) ||
				(pI2C_Message != I2C_Queue.pHead->pStatus))
				*pI2C_Message = CompletionCode;
		}
		I2C_State = S_MASTER_IDLE;		/* Next state. */

	  case S_MASTER_IDLE:		/* In reset state, waiting for data to send */
		if (I2C_Queue.empty)			/* Nothing to do, don't complain. */
			break;
		if (I2C_Queue.pHead->Bflag ||	/* Check that task is ready for transfer. */
			I2C_Queue.pHead->Iflag)		/* Next Task in Queue. */
		{								// grab the item pointed by the head
			pI2C_Current = I2C_Queue.pHead;
			pI2C_Message = pI2C_Current->pStatus;
			I2C_Timeout = I2C_Timer();		/* Timeout Start time. */
			I2C_State = S_MASTER_START;		/* Next state. */
		}								/* No break here, continue into S_MASTER_START */
		else
			break;						/* Nothing to do. */

	  case S_MASTER_START:
		/* Check if bus is Idle. This should be the case if P is true, special startup case P & S both 0. */
		if (I2CxSTATbits.S  == 0)
		{
			if (AddressHigh)			/* Workaround for 10-bit addressing. */
			{	I2CxCONbits.A10M = 0;	/* Disable 10 bit address mode. */
				I2CxADD = AddressHigh;	/* Set Reserved address. */
			}
		}
		else if (Multimaster)			/* If another master is active, this should resolve when transfer is complete. */
		{	I2C_Timeout = I2C_Timer();
			while (I2CxSTATbits.S  == 1)
			{	Nop();					/* This should be made nonblocking,
										 * may need a timer interrupt to tickle
										 * retry actions. */
										/* If debugging, it is allowed to stretch forever. */
				if (I2C_Timer() - I2C_Timeout >= 10000* MS_TICK)	/* Long timeout, if nothing else work. */
				{
				  #if defined __DEBUG
					__builtin_software_breakpoint();
				  #endif
					I2CxCONbits.I2CEN = 0;				/* Disable the module. */
					I2C_Check();
					I2CxCONbits.I2CEN = 1;				/* Enable the module. */
				}
			}
		}
		else	/* Bus is busy or jammed, setting Start condition now will cause Bus Collision. */
		{
			/* If Bus is busy by another Master, it will become Idle again soon,
			 * and we will get another interrupt when the bus is Free. */
			while (I2CxSTATbits.P == 0 || I2CxSTATbits.S == 1 )		/* Wait it out */
			{	Nop();}												/* Timeout? */
			/* If Bus is jammed, we will never get out without doing something. */
				I2CxCONbits.I2CEN = 0;				/* Disable the module. */
				I2C_Check();
				I2CxCONbits.I2CEN = 1;				/* Now enable the module. */
		}
		I2CxCONbits.SEN = 1;			// send the start condition
		*pI2C_Message = I2C_MESSAGE_ACTIVE;
		CompletionCode = I2C_MESSAGE_ACTIVE;
										// Set state for the next request
		I2C_State = S_MASTER_SEND_ADDR;
		break;

	  case S_MASTER_RESTART:
		/* check for pending i2c Request */

		// ... trigger a REPEATED START
		I2CxCONbits.RSEN = 1;

		// start the i2c request
		I2C_State = S_MASTER_SEND_ADDR;
		break;

	  case S_MASTER_SEND_ADDR_10BIT_LSB:
		if (I2CxSTATbits.ACKSTAT)
		{	I2C_Queue.Errors ++;
			I2C_Queue.AddressNACK = 1;
			I2C_Stop(I2C_ERROR_ADDRESS_NACK);	/* Error Stop must cancel linked tasks. */
		}
		else
		{	// Remove bit 0 as R/W is never sent here
			I2CxTRN = (i2c_address >> 1) & 0x00FF;

			// determine the next state, check R/W
			if (i2c_address & 0x01)
			{
				// if this is a read we must repeat start
				// the bus to perform a read
				I2C_State = S_MASTER_10BIT_RESTART;
			}
			else			/* this is a write continue writing data */
				I2C_State = S_MASTER_SEND_DATA;
		}
		break;

	  case S_MASTER_10BIT_RESTART:
		if (I2CxSTATbits.ACKSTAT)
		{	I2C_Queue.Errors++;
			I2C_Stop(I2C_ERROR_ADDRESS_NACK);
		}
		else							// ACK Status is good, restart the bus
		{	I2CxCONbits.RSEN = 1;

										// Set the address restart flag.
			i2c_10bit_address_restart = 1;

										// Resend the address as a read
			I2C_State = S_MASTER_SEND_ADDR;
		}
		break;

	  case S_MASTER_SEND_ADDR:
		/* Start has been sent, send the address byte */
            /* Start has been sent, check that Start was achieved, */
		if ((I2CxSTATbits.P == 1) || (I2CxSTATbits.S == 0))
		{	I2C_Queue.Errors ++;			/* Failed Start ! */
			//	__builtin_software_breakpoint();/* Hang here for debugging. */
			RetryCount ++;								//	Retry: Any kind of wait may need a timer.
			I2C_State = S_MASTER_START;
			I2C_MasterInterruptSET;			/* Set flag to get back. */
			I2C_Stop(I2C_MESSAGE_STUCK_START);
			break;
		}

		if (i2c_10bit_address_restart != 1)
		{
			// extract the information for this message
			i2c_address = pI2C_Current->Address & 0x0FFF;
			pi2c_buf_ptr = pI2C_Current->pBuffer;
			i2c_bytes_left = pI2C_Current->Length;
				if (pI2C_Current->Eflag)
					index = i2c_bytes_left -1;
				else
					index = 0;
		}

		// check for 10-bit address
			if (( pI2C_Current->Aflag || i2c_address > 0xFF)
					&& (0x0 != i2c_address))	/* General Call address is ordinary 7-bit address. */
            {
                if (i2c_10bit_address_restart)	/* == 1, Restart Read address */
                {
												/* resending address bits<9:8> with read bit set. */
					I2CxTRN = 0x00F1 | ((i2c_address >> 8) & 0x0006);
												/* Next state is to wait for Read address to be acknowledged */
                    I2C_State = S_MASTER_ACK_ADDR;
												/* reset the flag so the next access is ok */
                    i2c_10bit_address_restart = 0;
                }
				else							/* Initial 10-bit Write address */
				{								// we have a 10 bit address
												// send bits<9:8>
												// mask bit 0 as this is always a write
					I2CxTRN = 0x00F0 | ((i2c_address >> 8) & 0x0006);
					I2C_State = S_MASTER_SEND_ADDR_10BIT_LSB;
				}
			}
			else
			{	// Transmit the address
				I2CxTRN = i2c_address;
				if (i2c_address & 0x01)	// Next state is to wait for address to be acked
					I2C_State = S_MASTER_ACK_ADDR;
				else					// Next state is transmit
					I2C_State = S_MASTER_CHECK_ADDR;
			}
			break;

		case S_MASTER_CHECK_ADDR:		/*  Make sure the Address acknowledged. */
			if (I2CxSTATbits.ACKSTAT)
            {
                // Address Transmission was not acknowledged
				I2C_Queue.Errors++;
				I2C_Queue.AddressNACK = 1;	/* Address Not Acknowledged. */

                // Send a stop flag and go back to idle
			//	LATCbits.LATC6 = 1;
                I2C_Stop(I2C_ERROR_ADDRESS_NACK);
				break;
            }
			I2C_State = S_MASTER_SEND_DATA;
			//	Note: No break here, continue into S_MASTER_SEND_DATA

	  case S_MASTER_SEND_DATA:
		// Make sure the previous byte was acknowledged
		if (I2CxSTATbits.ACKSTAT)
		{
			// Transmission was not acknowledged
			I2C_Queue.Errors++;
			I2C_Queue.DataNACK = 1;

			// Reset the Ack flag	/* This is a Read-only bit, controlled by hardware. */
			I2CxSTATbits.ACKSTAT = 0;

			// Send a stop flag and go back to idle
			I2C_Stop(I2C_ERROR_DATA_NACK);
			break;
		}

			// Did we send them all ?
			if (i2c_bytes_left-- == 0U)
			{
				// yup sent them all!
				I2C_FunctionComplete(I2C_MESSAGE_COMPLETE);
				if (pI2C_Current != NULL)	/* extract the information for this message */
				{	i2c_address    = pI2C_Current->Address & 0x0FFF;
			        pi2c_buf_ptr   = pI2C_Current->pBuffer;
	                i2c_bytes_left = pI2C_Current->Length;
					pI2C_Message  = pI2C_Current->pStatus;
					if (pI2C_Current->Eflag)
						index = i2c_bytes_left -1;
					else
						index = 0;
				}
				if (I2C_State == S_MASTER_SEND_STOP)
				{	I2CxCONbits.PEN = 1;		/* Send stop condition signal */
					I2C_State = S_MASTER_COMPLETED;
					CompletionCode = I2C_MESSAGE_COMPLETE;
					break;
				}
				else if (I2C_State == S_MASTER_RESTART)
				{	if (pI2C_Current->Aflag)
						i2c_10bit_address_restart = 1;
					I2CxCONbits.RSEN = 1;
					I2C_State = S_MASTER_SEND_ADDR;		/* Resend Address next. */
					break;
				}
				else if (I2C_State == S_MASTER_SEND_DATA)
				{											/* Transmit the next data byte */
					i2c_bytes_left--;
				/* Nothing more here,
				 * pass into the next block to perform
				 *	I2C1_TRANSMIT_REG = *pi2c_buf_ptr++;
				 * No break here, and no break after the next else block. */
				}
				else							/* Something wrong, should not get here. */
					__builtin_software_breakpoint();/* Hang here for debugging. */
				/* No break here */
			}

			if (pI2C_Current->Bflag)	/* Transfer from user's buffer. */
			{	// Grab the next data to transmit
				I2CxTRN = *pi2c_buf_ptr++;
				break;
			}
			else if (pI2C_Current->Iflag )
			{	I2CxTRN = pI2C_Current->Data[index];
				if (pI2C_Current->Eflag)
					index--;
				else
					index++;
				break;
			}
			__builtin_software_breakpoint();/* Hang here for debugging. */
		break;

	  case S_MASTER_ACK_ADDR:
		if (I2CxSTATbits.ACKSTAT)		/* Make sure the read address byte was acknowledged */
		{
			// Transmission was not acknowledged
			I2C_Queue.Errors++;
			I2C_Queue.AddressNACK = 1;

			// Send a stop flag and go back to idle
			I2C_Stop(I2C_ERROR_ADDRESS_NACK);

			// Reset the Ack flag
			I2CxSTATbits.ACKSTAT = 0;
		}
		else
		{
			I2CxCONbits.RCEN = 1;
			I2C_State = S_MASTER_ACK_RCV_DATA;
		}
		break;

	  case S_MASTER_RCV_DATA:			/* Acknowledge is completed.  Time for more data */
		// Next thing is to ack the data
		I2C_State = S_MASTER_ACK_RCV_DATA;

		// Set up to receive a byte of data
		I2CxCONbits.RCEN = 1;
		break;

	  case S_MASTER_ACK_RCV_DATA:
		// Grab the byte of data received and acknowledge it
		*pi2c_buf_ptr++ = I2CxRCV;

		// Check if we received them all?
		if (--i2c_bytes_left)
		{
			/* No, there's more to receive */

			// No, bit 7 is clear.  Data is ok
			// Set the flag to acknowledge the data
			I2CxCONbits.ACKDT = 0;

			// Wait for the acknowledge to complete, then get more
			I2C_State = S_MASTER_RCV_DATA;
		}
		else
		{
			// Yes, it's the last byte.  Don't ack it
			// Flag that we will nak the data
			I2CxCONbits.ACKDT = 1;

			I2C_FunctionComplete(I2C_MESSAGE_COMPLETE);
			if (pI2C_Current != NULL)		/* Linked Task following? */
			{	i2c_address    = pI2C_Current->Address & 0x0FFF;
		        pi2c_buf_ptr   = pI2C_Current->pBuffer;
				i2c_bytes_left = pI2C_Current->Length;
				pI2C_Message = pI2C_Current->pStatus;
			}
		}
		// Initiate the acknowledge
		I2CxCONbits.ACKEN = 1;
		break;

	  case S_MASTER_RCV_STOP:
	  case S_MASTER_SEND_STOP:
		I2C_Stop(I2C_MESSAGE_COMPLETE);	// Send the stop signal sequence.
		break;

	  default:
		// This case should not happen, if it does then terminate the transfer.
		I2C_Queue.Errors++;
		I2C_Queue.LostState = 1;
		I2C_Stop(I2C_ERROR_LOST_STATE);
		break;
	}
	DIAG_INT_L;							/* Timing measurement signal. */

//  }
//  else if (I2C_BCLInterruptFlag)	// ( IFS1bits.I2C5BIF )
  #if (0)
	if (I2CxSTATbits.BCL)
  {	DIAG_INT_H;							/* Timing measurement signal. */
	LED_RedON();	//	LATFSET = 0x01;	/* LED2 Red  On */
										// Bus Collision or Arbitration lost
	I2C_Queue.Errors++;
	I2C_Queue.BusCollision = 1;
	/* Make a counter to record if Bus Collisions happen for every transfer. */
	CollisionCount ++;
//	I2C_BCLInterruptCLR;			//  IFS1bits.I2C5BIF = 0;	/* Clear interrupt Flag. */
	I2CxSTATbits.BCL = 0;			//  I2CxSTATbits.BCL = 0;	/* Clear Bus Collision Status. */

	/* Check that Current pointer correspond to Queue head */
	if (pI2C_Current == NULL || pI2C_Current != I2C_Queue.pHead )
	{	pI2C_Current = NULL;
		if (I2C_Queue.empty)
		{	I2C_State = S_MASTER_IDLE;		/* Next state. */
			return;
		}
		else if (I2C_Queue.pHead->Options )	/* Seem to be a pending entry. */
		{		I2C_State = S_MASTER_IDLE;
			I2C_MasterInterruptSET;			/* Set interrupt flag to keep going. */
			return;
		}
	}

	// make sure the flag pointer is not NULL

	/* Bus Collision during Start condition signalling, or during Address transmission should be retried. */
	if ((I2C_State == S_MASTER_START) || (I2C_State == S_MASTER_SEND_ADDR) || 
		(I2C_State == S_MASTER_SEND_ADDR_10BIT_LSB) || 
		(I2C_State == S_MASTER_CHECK_ADDR))
	{	RetryCount ++;
		if (I2C_State == S_MASTER_SEND_ADDR) 
			I2C_Queue.BclStart = 1; 
		else
			I2C_Queue.BclAddress = 1;		/* Note the event. */
		I2C_State = S_MASTER_START;
		*pI2C_Current->pStatus = I2C_MESSAGE_RETRY;
		I2C_MasterInterruptSET;			/* Set interrupt flag to get back. */
	}
	else if (I2C_State == S_MASTER_START || I2C_State == S_MASTER_IDLE)
	{	Nop();							/* If state is Start or Idle, just try again. */
		I2C_MasterInterruptSET;			/* Set interrupt flag to get back. */
	}
	/* Bus Collision during Data transfer must be Failed and removed from queue,
	 * including any linked queue entries. */
	else
	{	if (pI2C_Current->pStatus != NULL)	/* Update the flag with the completion code. */
			*pI2C_Current->pStatus = I2C_MESSAGE_FAIL;
		while (pI2C_Current->Lflag)		/* Linked transfer requests must be canceled on error conditions. */
		{	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
			pI2C_Current->Options = 0;	/* Clear flags */
			pI2C_Current = I2C_Queue.pHead;
		//	pI2C_Message = pI2C_Current->pStatus;
		}
		I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
		pI2C_Current = NULL;
		/* Check that I2C signal lines are Not Jammed */
		/* If SDA or SCL is permanent Low, and S is not recorded, bus may have been jammed in a Reset condition. */
		I2CxCONbits.I2CEN = 0;	// = _I2C1CON_ON_MASK;	/* Disable the module. */
		I2C_Check();						/* If real Multimaster, this shouldn't be done. */
		I2CxCONbits.I2CEN = 1;	// = _I2C1CON_ON_MASK;	/* Now enable the module. */
		// Done, back to idle
		I2C_State = S_MASTER_IDLE;
		I2C_MasterInterruptSET;			/* Set interrupt flag to get back. */
	}
	DIAG_INT_L;							/* Timing measurement signal. */
  }
  #endif
}

static inline void
I2C_FunctionComplete (I2C_MESSAGE_STATUS completion_code)
{
	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet, advance queue head pointer. */
#if (I2C_TASK_QUEUE_LENGTH > 1)
	if (pI2C_Current->pStatus == I2C_Queue.pHead->pStatus)	/* Will not work with queue length 1. */
		pI2C_Current->pStatus = NULL;	/* Pointer to Status word is reused in task packet */
	else								/* Update API Status word when whole chain completed. */
	{	if (*pI2C_Current->pStatus < I2C_MESSAGE_COMPLETE)
		{//	*pI2C_Current->pStatus = I2C_MESSAGE_COMPLETE;
			CompletionCode = I2C_MESSAGE_COMPLETE;
		}
		pI2C_Current->pStatus = NULL;
	}
		/* Test if tasks are linked, and queue not empty. */
	if ( pI2C_Current->Lflag &&  (I2C_Queue.empty == false))
	{									/* Next Task in Queue. */
		if (I2C_Queue.pHead->Bflag ||	/* Check that task is ready for transfer. */
			I2C_Queue.pHead->Iflag)
		{								/* Check that address is the same. */
			if ((pI2C_Current->Address & 0x07FE) == (I2C_Queue.pHead->Address & 0x07FE ))
			{	pI2C_Current->Options = 0;			/* Clear flags for completed task. */
				pI2C_Current = I2C_Queue.pHead;	/* This is New pointer to Linked task to be transferred now. */
			} else
			{	pI2C_Current->Options = 0;	/* Clear flags */
				pI2C_Current = NULL;
			}
		} else							/* There is an else to take care of here also. */
		{	pI2C_Current->Options = 0;	/* Link flag was set, but packet not ready. */
			pI2C_Current = NULL;
		}
	} else
	{	pI2C_Current->Options = 0;		/* Clear flags */
		pI2C_Current = NULL;			/* Clear the local pointer. */
	}

	/* Determine what to do next: */
	if (pI2C_Current == NULL)			/* Stop condition signal before next task. */
	    I2C_State = S_MASTER_SEND_STOP;
	else if (pI2C_Current->R_W )		/* Read operation, Repeat Start signal. */
		I2C_State = S_MASTER_RESTART;
	else								/* Continue Write operation without Restart */
		I2C_State = S_MASTER_SEND_DATA;
#else									/* This is for task queue length 1 only. */
	if (pI2C_Current != NULL)
	{	pI2C_Current->Options = 0;	/* Clear flags */
		if (pI2C_Current->pStatus != NULL)
		{	if (*pI2C_Current->pStatus < I2C_MESSAGE_COMPLETE)
				*pI2C_Current->pStatus = I2C_MESSAGE_COMPLETE;
			pI2C_Current->pStatus = NULL;
		}
	}
	I2C_State = S_MASTER_SEND_STOP;
	pI2C_Current = NULL;
#endif
}

static inline void
I2C_Stop (I2C_MESSAGE_STATUS completion_code)
{										/* Test that S bit is set and BCL is clear. */
	// then send a stop
	I2CxCONbits.PEN = 1;
	CompletionCode = completion_code;	/* Keep Completion Code until Stop signalling is really completed. */
	if (completion_code > I2C_MESSAGE_COMPLETE)
	{	while (pI2C_Current->Lflag)		/* Linked transfer requests must be canceled on error conditions. */
		{	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
			pI2C_Current->Options = 0;	/* Clear flags */
			pI2C_Current = I2C_Queue.pHead;
		//	pI2C_Message = pI2C_Current->pStatus;
		}
	}

	if (pI2C_Current != NULL)
	{	I2C_TaskRelease ( pI2C_Current);	/* Release the Task packet. */
		pI2C_Current->Options = 0;	/* Clear flags */

//      #if (I2C_TASK_QUEUE_LENGTH > 1)
//		if (( I2C_Queue.empty != 1) && (pI2C_Current->pStatus != NULL))
//		{	if (pI2C_Current->pStatus == I2C_Queue.pHead->pStatus)	/* Will not work with queue length 1. */
//				pI2C_Current->pStatus = NULL;	/* Pointer to Status word is reused in task packet */
//			else								/* Update API Status word when whole chain completed. */
//			{	if (*pI2C_Current->pStatus < I2C_MESSAGE_COMPLETE)
//					*pI2C_Current->pStatus = completion_code;
//				pI2C_Current->pStatus = NULL;
//			}
//		}
//		else
//      #endif
	}
	if (completion_code != I2C_MESSAGE_COMPLETE)
		if (pI2C_Current->pStatus != NULL)	// make sure Application status pointer is not NULL
			*(pI2C_Current->pStatus) = completion_code;	// update status with completion code

	I2C_State = S_MASTER_COMPLETED;	/* Do Not set IDLE state until Stop signalling is really completed. */
	// Done, back to idle				/* No! */
	//	I2C_State = S_MASTER_IDLE;		/* No! */

}

static inline	unsigned int
I2C_Timer(void)
{
#if defined __XC32__
	return _CP0_GET_COUNT();	/* MIPS system coprocessor performance Count register. */
#else
    return Tick;
#endif
}
/*******************************************************************************
 *	Check state of I2C bus, Try a Unjam operation if SDA is stuck.
 */
static inline void
I2C_Check(void)
{	static	int	Collision = 0;
	uint32_t	TimeOut;
	int c,	i,	n;					// Check State of the I2C bus
	if (I2CxCONbits.I2CEN == 1)		// Enabled
	{	if (I2CxSTATbits.BCL)		// Bus collision has occurred
		{	I2CxSTATbits.BCL = 0;	// Clear
			Collision += 1;
			if (Collision == 100)
				I2CxCONbits.I2CEN = 0;	// Disable I2C
	}	}
	if (I2CxCONbits.I2CEN == 0)		// Not enabled
	{	if (SCL_GetValue() == 0)	// Clock line busy
		{	n = 10000;
			while (SCL_GetValue() == 0)
			{	n--;
				if ( n == 0)		// Clock line timeout
					while(1);
		}	}
		n = 10000;
		while (SDA_GetValue() == 0)	// Data line busy
		{	n--;
			if ( n == 0)			// Data line timeout
			{							// Data line jammed
				c = 0;						// Try to clock the bus
				SCL_SetLow();					// Low
				for ( i = 0; i < 9; i++)
				{	TimeOut =  I2C_Timer();
					SCL_SetDigitalOutput();		// Output
												// 1 millisecond
					while (I2C_Timer() - TimeOut < MS_TICK);
					if (SDA_GetValue() == 0)	// Data line busy
						c += 1;
					TimeOut =  I2C_Timer();
					SCL_SetDigitalInput();		// Let Clock line go High
					while (I2C_Timer() - TimeOut < MS_TICK);
												// 1 millisecond
				}
				if (SDA_GetValue())				// Data line is Released.
				{								// Make Stop signal sequence
					SCL_SetDigitalOutput();		// Drive Clock line Low
					TimeOut = I2C_Timer();
					SDA_SetLow();
					SDA_SetDigitalOutput();		// Drive Data line Low
					while (I2C_Timer() - TimeOut < MS_TICK);
					SCL_SetDigitalInput();		// Let Clock line go High
					TimeOut = I2C_Timer();
					while (I2C_Timer() - TimeOut < MS_TICK);
					SDA_SetDigitalInput();		// Let Data line go High
					TimeOut = I2C_Timer();
					while (I2C_Timer() - TimeOut < MS_TICK);
					if (SDA_GetValue())			// If SDA and SCL are High, then bus is free.
						break;
				}
				if (c < 8)
					n = 10;
				else
					break;
		}	}
}	}

#if (0)
void
I2Cx_MasterWrite (
				  uint8_t *pdata,
				  uint8_t length,
				  uint16_t address,
				  I2C_MESSAGE_STATUS *pstatus)
{
	static volatile I2C_TRANSACTION_REQUEST_BLOCK trBlock;

	// check if there is space in the queue
	if (I2C_Queue.full != true)
	{
		I2C5_MasterWriteTRBBuild(&trBlock, pdata, length, address);
		I2C5_MasterTRBInsert(1, &trBlock, pstatus);
	}
	else
	{
		*pstatus = I2C_MESSAGE_QUEUE_FULL;	// = I2C_MESSAGE_FAIL;
	}
}

void
I2Cx_MasterRead (
				 uint8_t *pdata,
				 uint8_t length,
				 uint16_t address,
				 I2C_MESSAGE_STATUS *pstatus)
{
	static volatile I2C_TRANSACTION_REQUEST_BLOCK trBlock;

	// check if there is space in the queue
	if (I2C_Queue.full != true)
	{
		I2Cx_MasterReadTRBBuild(&trBlock, pdata, length, address);
		I2Cx_MasterTRBInsert(1, &trBlock, pstatus);
	}
	else
	{
		*pstatus = I2C_MESSAGE_QUEUE_FULL;	// = I2C_MESSAGE_FAIL;
	}
}
#endif

/* This interface is supported by repacking TRB into revised driver Task queue.
 * For this to succeed, Task queue must have sufficient free entries available
 * for 'count' task queue entries. */
void
I2Cx_MasterTRBInsert (
					  uint8_t count,
					  I2C_TRANSACTION_REQUEST_BLOCK *ptrb_list,
					  I2C_MESSAGE_STATUS *pflag)
{
	I2C_TASK	*pTask;
	// check if there is space in the queue
	if (I2C_Queue.full != true)
	{
		*pflag = I2C_MESSAGE_PENDING;

		while (count)
		{	pTask = I2C_TaskReserve ( count);
			if (pTask == NULL)
			{  *pflag = I2C_MESSAGE_QUEUE_FULL;
				return;
			}
			pTask->Address = ptrb_list->address;
			pTask->Length  = ptrb_list->length;
			pTask->pBuffer = ptrb_list->pbuffer;
			pTask->pStatus = pflag;
			if (count > 1)
				pTask->Lflag = 1;
			pTask->Bflag   = 1;
			ptrb_list++;
			count--;
		}

		// for interrupt based
		if (I2C_State == S_MASTER_IDLE)
		{
			// force the task to run since we know that the queue has
			// something that needs to be sent
			I2C_MasterInterruptSET;
		}
	}
	else
	{									/* Using I2C_MESSAGE_FAIL for Status when Queue full occur is a mistake. */
										/* The condition that most easily may be recovered by retrying in application code
										 * get the unspecific status that make the example application fail. */
		*pflag = I2C_ERROR_FAIL;		/* I2C_MESSAGE_QUEUE_FULL; */
	}
}


void
I2Cx_MasterReadTRBBuild (
						 I2C_TRANSACTION_REQUEST_BLOCK *ptrb,
						 uint8_t *pdata,
						 uint8_t length,
						 uint16_t address)
{
	ptrb->address = address << 1;
	// make this a read
	ptrb->address |= 0x01;
	ptrb->length = length;
	ptrb->pbuffer = pdata;
}

void
I2Cx_MasterWriteTRBBuild (
						  I2C_TRANSACTION_REQUEST_BLOCK *ptrb,
						  uint8_t *pdata,
						  uint8_t length,
						  uint16_t address)
{
	ptrb->address = address << 1;
	ptrb->length = length;
	ptrb->pbuffer = pdata;
}

bool
I2Cx_MasterQueueIsEmpty (void)
{
	return (I2C_Queue.empty);
}

bool
I2Cx_MasterQueueIsFull (void)
{
	return (I2C_Queue.full);
}

/**
 End of File
 */
